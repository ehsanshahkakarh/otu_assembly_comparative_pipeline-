#!/usr/bin/env python3
"""
Isolate Information Sanity Check

This script analyzes the 'isolate' column from the NCBI assembly file to understand
what isolate information is available and how it relates to genome classification.

According to NCBI README, the isolate column should be empty if not an isolate,
so we'll analyze both filled and empty values to understand the data distribution.

Created: 2025-07-29 17:57:00
Last Modified: 2025-08-02 01:35:00
Author: Generated by Augment Agent

Purpose: Analyzes isolate information distribution and quality in NCBI assembly data.
"""

import pandas as pd
from pathlib import Path
import sys

def main():
    print("üî¨ ISOLATE INFORMATION SANITY CHECK")
    print("=" * 60)
    
    # File paths (assembly file is in parent directory)
    script_dir = Path(__file__).resolve().parent
    assembly_file = script_dir.parent / "00assembly_summary_genbank.txt"
    
    if not assembly_file.exists():
        print(f"‚ùå Assembly file not found: {assembly_file}")
        sys.exit(1)
    
    print(f"üìÅ Reading assembly file: {assembly_file.name}")
    
    # Read assembly file with proper header handling
    with open(assembly_file, 'r') as f:
        lines = f.readlines()
    
    # Find the header line (starts with #assembly_accession)
    header_line = None
    data_start = 0
    for i, line in enumerate(lines):
        if line.startswith('#assembly_accession'):
            header_line = line.strip().lstrip('#')
            data_start = i + 1
            break
    
    if header_line is None:
        print("‚ùå Could not find header line in assembly file")
        sys.exit(1)
    
    # Read the data with the correct header
    print("üìñ Loading assembly data...")
    df = pd.read_csv(assembly_file, sep='\t', low_memory=False, 
                     skiprows=data_start, names=header_line.split('\t'))
    
    print(f"‚úÖ Loaded {len(df):,} assembly entries")
    
    # Check if isolate column exists
    if 'isolate' not in df.columns:
        print("‚ùå 'isolate' column not found in assembly file")
        print(f"Available columns: {list(df.columns)}")
        sys.exit(1)
    
    print(f"‚úÖ Found 'isolate' column")
    
    # Analyze isolate column
    print("\n" + "=" * 60)
    print("üìä ISOLATE COLUMN ANALYSIS")
    print("=" * 60)
    
    # Basic statistics
    total_entries = len(df)
    isolate_col = df['isolate']
    
    # Define placeholder values that don't represent real isolate information
    placeholder_values = [
        'na', 'n/a', 'not applicable', 'not available', 'unknown', 'unspecified',
        'none', 'null', 'missing', 'not provided', 'not given', 'not specified',
        'not determined', 'not reported', 'not stated', 'not mentioned'
    ]

    # Count different types of values
    non_null_count = isolate_col.notna().sum()
    null_count = isolate_col.isna().sum()
    empty_string_count = (isolate_col == '').sum()

    # Check for placeholder values (case-insensitive)
    is_placeholder = isolate_col.fillna('').str.lower().str.strip().isin(placeholder_values)
    placeholder_count = is_placeholder.sum()

    # Real isolate information = non-null, non-empty, non-placeholder
    filled_count = ((isolate_col.notna()) & (isolate_col != '') & (~is_placeholder)).sum()
    total_non_isolate = null_count + empty_string_count + placeholder_count
    
    print(f"Total entries: {total_entries:,}")
    print(f"Non-null values: {non_null_count:,} ({non_null_count/total_entries*100:.2f}%)")
    print(f"Null/NaN values: {null_count:,} ({null_count/total_entries*100:.2f}%)")
    print(f"Empty strings: {empty_string_count:,} ({empty_string_count/total_entries*100:.2f}%)")
    print(f"Placeholder values (na, etc.): {placeholder_count:,} ({placeholder_count/total_entries*100:.2f}%)")
    print(f"REAL isolate names: {filled_count:,} ({filled_count/total_entries*100:.2f}%)")
    print(f"Total non-isolate entries: {total_non_isolate:,} ({total_non_isolate/total_entries*100:.2f}%)")
    
    # Show examples of real isolate values (excluding placeholders)
    if filled_count > 0:
        print(f"\nüìã EXAMPLES OF REAL ISOLATE VALUES (showing first 20):")
        real_isolates = df[(df['isolate'].notna()) & (df['isolate'] != '') & (~is_placeholder)]['isolate'].unique()[:20]
        for i, isolate in enumerate(real_isolates, 1):
            print(f"  {i:2d}. {isolate}")

    # Show examples of placeholder values
    if placeholder_count > 0:
        print(f"\nüìã EXAMPLES OF PLACEHOLDER VALUES:")
        placeholder_examples = df[is_placeholder]['isolate'].value_counts().head(10)
        for isolate, count in placeholder_examples.items():
            print(f"  '{isolate}': {count:,} entries")
    
    # Basic comparison between entries with real isolates vs non-isolates
    print(f"\nüîç BASIC COMPARISON:")

    # Real isolates (excluding placeholders)
    real_isolate_df = df[(df['isolate'].notna()) & (df['isolate'] != '') & (~is_placeholder)]
    # Non-isolates (null, empty, or placeholder)
    non_isolate_df = df[(df['isolate'].isna()) | (df['isolate'] == '') | (is_placeholder)]

    print(f"Entries with REAL isolate names: {len(real_isolate_df):,}")
    print(f"Entries without isolate info (null/empty/placeholder): {len(non_isolate_df):,}")

    # Compare assembly levels
    if len(real_isolate_df) > 0:
        print(f"\nAssembly levels for entries WITH real isolate info:")
        isolate_assembly_levels = real_isolate_df['assembly_level'].value_counts()
        for level, count in isolate_assembly_levels.head().items():
            print(f"  {level}: {count:,} ({count/len(real_isolate_df)*100:.1f}%)")

    if len(non_isolate_df) > 0:
        print(f"\nAssembly levels for entries WITHOUT isolate info:")
        non_isolate_assembly_levels = non_isolate_df['assembly_level'].value_counts()
        for level, count in non_isolate_assembly_levels.head().items():
            print(f"  {level}: {count:,} ({count/len(non_isolate_df)*100:.1f}%)")
    
    # Create output files
    print(f"\nüíæ CREATING OUTPUT FILES...")

    # 1. All rows with REAL isolate information (excluding placeholders)
    real_isolates_output_df = real_isolate_df.copy()
    isolates_file = script_dir / "entries_with_real_isolate_info.csv"

    # Select relevant columns for isolate entries
    isolate_columns = ['assembly_accession', 'organism_name', 'isolate', 'assembly_level',
                      'taxid', 'species_taxid', 'excluded_from_refseq', 'genome_size']
    real_isolates_output = real_isolates_output_df[isolate_columns].copy()
    real_isolates_output.to_csv(isolates_file, index=False)
    print(f"‚úÖ Saved entries with REAL isolate info: {isolates_file} ({len(real_isolates_output_df):,} entries)")

    # 2. Statistics file
    stats_file = script_dir / "isolate_statistics.csv"

    # Create statistics dataframe
    stats_data = []

    # Basic counts
    stats_data.append(['total_entries', total_entries])
    stats_data.append(['entries_with_isolate_info', filled_count])
    stats_data.append(['entries_without_isolate_info', total_entries - filled_count])
    stats_data.append(['percentage_with_isolate', round(filled_count/total_entries*100, 2)])

    # Assembly level breakdown for entries with real isolates
    if len(real_isolate_df) > 0:
        assembly_level_counts = real_isolate_df['assembly_level'].value_counts()
        for level, count in assembly_level_counts.items():
            stats_data.append([f'real_isolate_entries_{level.lower().replace(" ", "_")}', count])

    # Assembly level breakdown for entries without isolates (including placeholders)
    if len(non_isolate_df) > 0:
        assembly_level_counts_non = non_isolate_df['assembly_level'].value_counts()
        for level, count in assembly_level_counts_non.items():
            stats_data.append([f'non_isolate_entries_{level.lower().replace(" ", "_")}', count])

    # Unique real isolate names count
    unique_isolate_names = real_isolate_df['isolate'].nunique() if len(real_isolate_df) > 0 else 0
    stats_data.append(['unique_real_isolate_names', unique_isolate_names])

    # Average genome size comparison
    if len(real_isolate_df) > 0 and len(non_isolate_df) > 0:
        isolate_avg_size = real_isolate_df['genome_size'].mean()
        non_isolate_avg_size = non_isolate_df['genome_size'].mean()
        stats_data.append(['avg_genome_size_with_real_isolate', round(isolate_avg_size, 0)])
        stats_data.append(['avg_genome_size_without_isolate', round(non_isolate_avg_size, 0)])

    # Create and save stats dataframe
    stats_df = pd.DataFrame(stats_data, columns=['statistic', 'value'])
    stats_df.to_csv(stats_file, index=False)
    print(f"‚úÖ Saved statistics: {stats_file}")

    # 3. Sample of REAL isolate names for analysis
    if len(real_isolate_df) > 0:
        sample_file = script_dir / "real_isolate_names_sample.csv"

        # Get unique real isolate names with counts
        isolate_name_counts = real_isolate_df['isolate'].value_counts().reset_index()
        isolate_name_counts.columns = ['isolate_name', 'count']

        # Add some example organism names for each isolate
        isolate_examples = []
        for isolate_name in isolate_name_counts['isolate_name'].head(100):  # Top 100 most common
            examples = real_isolate_df[real_isolate_df['isolate'] == isolate_name]['organism_name'].head(3).tolist()
            isolate_examples.append('; '.join(examples))

        isolate_name_counts_sample = isolate_name_counts.head(100).copy()
        isolate_name_counts_sample['example_organisms'] = isolate_examples

        isolate_name_counts_sample.to_csv(sample_file, index=False)
        print(f"‚úÖ Saved REAL isolate names sample: {sample_file} (top 100 most common)")
    
    # Show some examples from the isolate data
    print(f"\nüìã EXAMPLES OF ISOLATE DATA:")

    if len(real_isolate_df) > 0:
        print(f"\nEntries WITH REAL isolate information (first 10):")
        for i, (_, row) in enumerate(real_isolate_df.head(10).iterrows()):
            print(f"  {i+1:2d}. {row['organism_name']} | isolate: {row['isolate']}")

    if len(non_isolate_df) > 0:
        print(f"\nEntries WITHOUT isolate information (first 5):")
        for i, (_, row) in enumerate(non_isolate_df.head(5).iterrows()):
            isolate_val = row['isolate'] if pd.notna(row['isolate']) and row['isolate'] != '' else '[empty/null]'
            print(f"  {i+1:2d}. {row['organism_name']} | isolate: {isolate_val}")

    print(f"\n" + "=" * 60)
    print(f"‚úÖ ISOLATE ANALYSIS COMPLETE!")
    print(f"üìä Key findings:")
    print(f"   - {filled_count:,} entries have isolate names ({filled_count/total_entries*100:.2f}%)")
    print(f"   - {null_count + empty_string_count:,} entries have empty/null isolate field ({(null_count + empty_string_count)/total_entries*100:.2f}%)")
    print(f"   - {unique_isolate_names:,} unique isolate names found")
    print(f"\nüìÅ Generated files:")
    print(f"   - entries_with_real_isolate_info.csv: All entries with REAL isolate information")
    print(f"   - isolate_statistics.csv: Detailed statistics")
    print(f"   - real_isolate_names_sample.csv: Sample of most common REAL isolate names")
    print(f"=" * 60)

if __name__ == "__main__":
    main()
